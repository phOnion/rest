{
    "docs": [
        {
            "location": "/", 
            "text": "Documentation\n\n\nThis is a minimal package that provides the different types\nof REST compatible response serializers. It uses object mappings\nto define how and what to build a response entity. At the moment\nit only supports JSON responses, although there are plans for \nsupporting HAL-XML it is on the todo list and with low priority\nsince JSON-LD and JSON-API responses are more important and more\nwidely used in general + the overhead is minimal.\n\n\nCurrently this package supports transformation of objects to:\n\n\n\n\napplication/json\n - This is almost the same as doing \njson_encode\n on \n a data array.\n\n\napplication/hal+json\n - This is a fully HAL compliant response\n along with links and embedded entities.\n\n\napplication/api+json\n - Well... JSON-API most of it should be working file\n\n\napplication/ld+json\n - This is the most tricky part. The spec is kinda complex and some features are not supported as of now.\n\n\n\n\nFor more information on each of the serializers take a look at their respective section in the documentation.", 
            "title": "Home"
        }, 
        {
            "location": "/#documentation", 
            "text": "This is a minimal package that provides the different types\nof REST compatible response serializers. It uses object mappings\nto define how and what to build a response entity. At the moment\nit only supports JSON responses, although there are plans for \nsupporting HAL-XML it is on the todo list and with low priority\nsince JSON-LD and JSON-API responses are more important and more\nwidely used in general + the overhead is minimal.  Currently this package supports transformation of objects to:   application/json  - This is almost the same as doing  json_encode  on \n a data array.  application/hal+json  - This is a fully HAL compliant response\n along with links and embedded entities.  application/api+json  - Well... JSON-API most of it should be working file  application/ld+json  - This is the most tricky part. The spec is kinda complex and some features are not supported as of now.   For more information on each of the serializers take a look at their respective section in the documentation.", 
            "title": "Documentation"
        }, 
        {
            "location": "/mappings/", 
            "text": "Introduction\n\n\nThe mappings are arrays passed to the transformer, from which it can workout what goes where. \n\n\nAn typical mapping looks something like:\n\n\n$mapping = [\n    \\Acme\\DataObject::class =\n [\n        'links' =\n [\n            ['rel' =\n 'self', 'href' =\n '/entityLocation/{id}'],\n            // more links\n        ],\n        'fields' =\n ['id', 'field1', 'field2', ...],\n        'relations' =\n [\n            'relationType' =\n // This is important in some serializations\n                'method' // The name of the method to call on the object to retrieve the related data\n        ],\n        'meta' =\n [\n            'ld' =\n [], // JSON-LD meta data\n            'api' =\n [], // JSON-API meta data\n        ]\n    ]\n];\n\n\n\n\nLinks\n\n\nLinks are part of HATEOAS in order to allow clients to \"navigate\" inside the returned data, also they allow lowering the footprint of the response by allowing the client to request the resources they need instead of receiving a huge JSON blob, regardless of the client's needs.\n\n\nA link definition is an array with mandatory: \nrel\n \n \nhref\n fields, everything else is pushed as additional attributes to the link.\n\n\nFields\n\n\nThe list of fields, which \ncan\n be retrieved from the object (\ncan\n, because the transformer provides the ability to provide fields and resources to return).\n\n\nRelations\n\n\nRelations are a \n'field' =\n 'method'\n relation. This is mainly useful for LD responses, since with them the type of the object is not the same as the filed they get populated because of the schema usage as opposed to HAL.\n\n\nMeta\n\n\nMeta data should be handled with respect to \nld\n and \napi\n keys, since those are special-case where data for JSON- LD and API have different purpose, but in order to define mappings for multiple response types (most appropriate scenario one is content negotiation) so care should be taken.\n\n\nKeep in mind that the \nHydratableInterface\n is a general purpose interface to allow hydration/extraction of object data.", 
            "title": "Mappings"
        }, 
        {
            "location": "/mappings/#introduction", 
            "text": "The mappings are arrays passed to the transformer, from which it can workout what goes where.   An typical mapping looks something like:  $mapping = [\n    \\Acme\\DataObject::class =  [\n        'links' =  [\n            ['rel' =  'self', 'href' =  '/entityLocation/{id}'],\n            // more links\n        ],\n        'fields' =  ['id', 'field1', 'field2', ...],\n        'relations' =  [\n            'relationType' =  // This is important in some serializations\n                'method' // The name of the method to call on the object to retrieve the related data\n        ],\n        'meta' =  [\n            'ld' =  [], // JSON-LD meta data\n            'api' =  [], // JSON-API meta data\n        ]\n    ]\n];", 
            "title": "Introduction"
        }, 
        {
            "location": "/mappings/#links", 
            "text": "Links are part of HATEOAS in order to allow clients to \"navigate\" inside the returned data, also they allow lowering the footprint of the response by allowing the client to request the resources they need instead of receiving a huge JSON blob, regardless of the client's needs.  A link definition is an array with mandatory:  rel     href  fields, everything else is pushed as additional attributes to the link.", 
            "title": "Links"
        }, 
        {
            "location": "/mappings/#fields", 
            "text": "The list of fields, which  can  be retrieved from the object ( can , because the transformer provides the ability to provide fields and resources to return).", 
            "title": "Fields"
        }, 
        {
            "location": "/mappings/#relations", 
            "text": "Relations are a  'field' =  'method'  relation. This is mainly useful for LD responses, since with them the type of the object is not the same as the filed they get populated because of the schema usage as opposed to HAL.", 
            "title": "Relations"
        }, 
        {
            "location": "/mappings/#meta", 
            "text": "Meta data should be handled with respect to  ld  and  api  keys, since those are special-case where data for JSON- LD and API have different purpose, but in order to define mappings for multiple response types (most appropriate scenario one is content negotiation) so care should be taken.  Keep in mind that the  HydratableInterface  is a general purpose interface to allow hydration/extraction of object data.", 
            "title": "Meta"
        }, 
        {
            "location": "/transformer/", 
            "text": "Intro\n\n\nThe transformer is the object which creates the intermediate representation of the resource to be serialized. This is especially useful, since it abstracts away the actual object from the serializer and does not require you to follow any conventions or anything that can get in the way of your object.\nUnless , obviously, if you consider the requirement to implement \nHydratebleInterface\n, but if you put the time to implement a single 'hydratable' trait you will be fine. \n\n\nThis decision came from the need to sometimes hydrate objects in bulk without writing boilerplate code, handling naming translations, etc or extracting all data from the object. Also there is no mandatory requirement to use one big array with all the mappings, for example you might create a method and store the meta-data inside the hydratable object itself, but that is up to a personal preference and up to your taste (also, remember.. no convention required :) )\n\n\nFilter relations\n\n\nThe \ntransform\n method also supports 2 additional arguments, which specify, the 2nd being \narray $includes = []\n that is should contain a list of values representing the relations to retrieve. So for example if you make a request to \n/products?include=price\n this should return a list \nproduct\ns and only retrieve the \nprice\n relation, ignoring anything else like, list of components, similar products, etc.\n\n\nFilter relation fields\n\n\nThis sort of filtering allows for clients to request only a set of fields for a given relation. This might be useful for requests that intend to update only a small set of their details and not go through the whole process of recreating the data and/or being on a metered data connection (because we should care!). So building upon the previous example with products and price, this one could be like: \n/products?include=price\nfields[price]=total\n this will return all products only with their price relation, which now will only include the total price, instead of - say - delivery, VAT or anything else.\n\n\n## Conclusion\nThis might prove to be especially useful for mobile clients which work on metered connections so that they only update what they need to check or to provide a speedier experience, for example when checking for messages, instead of puling the whole messages, a client might pull only the id and sender and on interaction to pull the actual message (instead of wasting data in bulk most of the time).\n\n\nNote that the examples above use only examples of how data can be provided. Actual passing of the filtering criteria is up to the utilizing implementation and nothing is being handled by default (why would object need access to globals, special keys or anything - Tell don't ask :) ). Some ideas:\n\n\n\n\n?include=product,provider\nfields=product:id,title;provider:name\n\n\n?include=product,provider\nfields[product]=id,title\nfields[provider]=name\n\n\n?include[]=product\ninclude[]=provider\nfields[product][]=id\nfields[product][]=name", 
            "title": "Transformer"
        }, 
        {
            "location": "/transformer/#intro", 
            "text": "The transformer is the object which creates the intermediate representation of the resource to be serialized. This is especially useful, since it abstracts away the actual object from the serializer and does not require you to follow any conventions or anything that can get in the way of your object.\nUnless , obviously, if you consider the requirement to implement  HydratebleInterface , but if you put the time to implement a single 'hydratable' trait you will be fine.   This decision came from the need to sometimes hydrate objects in bulk without writing boilerplate code, handling naming translations, etc or extracting all data from the object. Also there is no mandatory requirement to use one big array with all the mappings, for example you might create a method and store the meta-data inside the hydratable object itself, but that is up to a personal preference and up to your taste (also, remember.. no convention required :) )", 
            "title": "Intro"
        }, 
        {
            "location": "/transformer/#filter-relations", 
            "text": "The  transform  method also supports 2 additional arguments, which specify, the 2nd being  array $includes = []  that is should contain a list of values representing the relations to retrieve. So for example if you make a request to  /products?include=price  this should return a list  product s and only retrieve the  price  relation, ignoring anything else like, list of components, similar products, etc.", 
            "title": "Filter relations"
        }, 
        {
            "location": "/transformer/#filter-relation-fields", 
            "text": "This sort of filtering allows for clients to request only a set of fields for a given relation. This might be useful for requests that intend to update only a small set of their details and not go through the whole process of recreating the data and/or being on a metered data connection (because we should care!). So building upon the previous example with products and price, this one could be like:  /products?include=price fields[price]=total  this will return all products only with their price relation, which now will only include the total price, instead of - say - delivery, VAT or anything else.  ## Conclusion\nThis might prove to be especially useful for mobile clients which work on metered connections so that they only update what they need to check or to provide a speedier experience, for example when checking for messages, instead of puling the whole messages, a client might pull only the id and sender and on interaction to pull the actual message (instead of wasting data in bulk most of the time).  Note that the examples above use only examples of how data can be provided. Actual passing of the filtering criteria is up to the utilizing implementation and nothing is being handled by default (why would object need access to globals, special keys or anything - Tell don't ask :) ). Some ideas:   ?include=product,provider fields=product:id,title;provider:name  ?include=product,provider fields[product]=id,title fields[provider]=name  ?include[]=product include[]=provider fields[product][]=id fields[product][]=name", 
            "title": "Filter relation fields"
        }, 
        {
            "location": "/serializers/intro/", 
            "text": "Serializers Intro\n\n\nSerializers are the object that do the heavy lifting. They serialize\nthe entity representing the extracted data and it's relations. They are responsible to serialize the object to a string representation for the client.\n\n\nSerializers should not accept any external parameters and their behavior should depend only on the datastructure they are working with.", 
            "title": "Introduction"
        }, 
        {
            "location": "/serializers/intro/#serializers-intro", 
            "text": "Serializers are the object that do the heavy lifting. They serialize\nthe entity representing the extracted data and it's relations. They are responsible to serialize the object to a string representation for the client.  Serializers should not accept any external parameters and their behavior should depend only on the datastructure they are working with.", 
            "title": "Serializers Intro"
        }, 
        {
            "location": "/serializers/plain_json/", 
            "text": "Plain JSON serializer\n\n\nAt most this is basically a call to \njson_encode\n wrapped in an\nobject, calling \nEntity::getData()\n for the response... Nothing fancy.", 
            "title": "Plain JSON"
        }, 
        {
            "location": "/serializers/plain_json/#plain-json-serializer", 
            "text": "At most this is basically a call to  json_encode  wrapped in an\nobject, calling  Entity::getData()  for the response... Nothing fancy.", 
            "title": "Plain JSON serializer"
        }, 
        {
            "location": "/serializers/json_hal/", 
            "text": "HAL serializer\n\n\nSerializes the entity and its child entities as a HAL response. Automatically attempts to populate links with the appropriate \nvalues from the retrieved data. AFAICT it should be fully compatible with the HAL specification (except maybe for compact\nresponses, but those are left out on purpose)", 
            "title": "JSON HAL"
        }, 
        {
            "location": "/serializers/json_hal/#hal-serializer", 
            "text": "Serializes the entity and its child entities as a HAL response. Automatically attempts to populate links with the appropriate \nvalues from the retrieved data. AFAICT it should be fully compatible with the HAL specification (except maybe for compact\nresponses, but those are left out on purpose)", 
            "title": "HAL serializer"
        }, 
        {
            "location": "/serializers/json_api/", 
            "text": "JSON API\n\n\nSerializer that converts the data to a JSON-API response.\nThis is as far as I can see compatible with the documentation,\nbut bugs might be expected since I am not 100% familiar with \nthe spec in general.", 
            "title": "JSON-API"
        }, 
        {
            "location": "/serializers/json_api/#json-api", 
            "text": "Serializer that converts the data to a JSON-API response.\nThis is as far as I can see compatible with the documentation,\nbut bugs might be expected since I am not 100% familiar with \nthe spec in general.", 
            "title": "JSON API"
        }, 
        {
            "location": "/serializers/json_ld/", 
            "text": "JSON-LD\n\n\nThis is mostly a very big experiment, I have never used JSON-LD\nat all for anything and this is a feature that may require\nthroughout testing to identify issues, also some features might be missing, but they seem to be more or less out of scope + too time consuming for investigation at this stage.", 
            "title": "JSON-LD"
        }, 
        {
            "location": "/serializers/json_ld/#json-ld", 
            "text": "This is mostly a very big experiment, I have never used JSON-LD\nat all for anything and this is a feature that may require\nthroughout testing to identify issues, also some features might be missing, but they seem to be more or less out of scope + too time consuming for investigation at this stage.", 
            "title": "JSON-LD"
        }
    ]
}